/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.analyzer.vulnerabilityplugin.utils.parsers;

import eu.fasten.analyzer.vulnerabilityplugin.utils.Vulnerability;
import javax.xml.parsers.ParserConfigurationException;

import eu.fasten.analyzer.vulnerabilityplugin.utils.connections.JavaHttpClient;
import eu.fasten.analyzer.vulnerabilityplugin.utils.mappers.VersionRanger;
import kotlin.Pair;
import org.apache.kafka.common.utils.Java;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xml.sax.SAXException;
// DOM imports
import org.w3c.dom.*;
import javax.xml.parsers.*;
import java.io.*;
import java.util.HashMap;
import java.util.List;

/**
 * This parser handles all OVAL imports.
 */
public class OVALParser implements VulnerabilityParser {

    private HashMap<String, Vulnerability> vulnerabilities;
    private static JavaHttpClient client;
    private static VersionRanger versionRanger;
    private static final Logger logger = LoggerFactory.getLogger(ExtraParser.class.getName());

    /**
     * The same client is injected in both OVALParser and the VersionRanger.
     * This will help with Mocking when testing later.
     *
     * @param client - JavaHttpClient
     */
    public OVALParser(JavaHttpClient client, VersionRanger versionRanger) {
        this.vulnerabilities = new HashMap<>();
        this.versionRanger = versionRanger;
        this.client = client;
    }

    /**
     * Small helper to look up what is in memory
     * @return - map of vulnerabilities
     */
    public HashMap<String, Vulnerability> getVulnerabilitiesInMemory() {
        return vulnerabilities;
    }

    /**
     * The main source of information to get vulnerabilities is Debian.
     * Here is the link to the XML file:
     * @return
     */
    @Override
    public HashMap<String, Vulnerability> getVulnerabilities() {
        // Download Buster OVAL XML file
        String ovalXML = null;
        try {
            logger.info("Downloading Buster OVAL from Debian Security Website");
            ovalXML = client.sendGet("https://www.debian.org/security/oval/oval-definitions-buster.xml");
        } catch (Exception e) {
            logger.error("Cannot downloaded Buster OVAL from Debian Security Website");
            e.printStackTrace();
        }
        // Read the XML file
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder = null;
        Document document = null;
        try {
            builder = factory.newDocumentBuilder();
            InputStream is = new ByteArrayInputStream(ovalXML.getBytes());
            document = builder.parse(is);
        } catch (ParserConfigurationException e) {
            logger.error("Error while parsing the OVAL xml file - ParserConfigException");
            e.printStackTrace();
        } catch (SAXException e) {
            logger.error("Error while parsing the OVAL xml file - SAXException");
            e.printStackTrace();
        } catch (IOException e) {
            logger.error("Error while parsing the OVAL xml file - IOException");
            e.printStackTrace();
        }

        // Normalize XML Structure
        document.getDocumentElement().normalize();

        // Prepare placeholders for all the information to gather
        HashMap<String, Pair<String, String>> ovalTestMap = new HashMap<>();
        HashMap<String, String> ovalObjectMap = new HashMap<>();
        HashMap<String, String> ovalStateMap = new HashMap<>();

        // Parse all OvalTests and put them into a HashMap
        NodeList ovalTests = document.getElementsByTagName("dpkginfo_test");

        for (int i = 0; i < ovalTests.getLength(); i++) {
            Node node = ovalTests.item(i);
            Element eElement = (Element) node;
            Element object = (Element) eElement.getElementsByTagName("object").item(0);
            Element state = (Element) eElement.getElementsByTagName("state").item(0);

            String testId = eElement.getAttribute("id");
            String objectRef = object.getAttribute("object_ref");
            String stateRef = state.getAttribute("state_ref");

            ovalTestMap.put(testId, new Pair<>(objectRef, stateRef));
        }

        // Parse all OvalObjects and put them into a HashMap
        NodeList ovalObjects = document.getElementsByTagName("dpkginfo_object");

        for (int i = 0; i < ovalObjects.getLength(); i++) {
            Node node = ovalObjects.item(i);
            Element eElement = (Element) node;
            Element object = (Element) eElement.getElementsByTagName("name").item(0);
            String objectId = eElement.getAttribute("id");
            String objectName = object.getTextContent();

            ovalObjectMap.put(objectId, objectName);
        }

        // Parse all OvalStates and put them into a HashMap
        NodeList ovalStates = document.getElementsByTagName("dpkginfo_state");

        for (int i = 0; i < ovalStates.getLength(); i++) {
            Node node = ovalStates.item(i);
            Element eElement = (Element) node;
            Element version = (Element) eElement.getElementsByTagName("evr").item(0);
            String stateId = eElement.getAttribute("id");
            String stateVersions = version.getTextContent();

            ovalStateMap.put(stateId, stateVersions);
        }

        // Parse all OvalDefinitions and create vulnerability objects
        NodeList nList = document.getElementsByTagName("definition");

        for (int i = 0; i < nList.getLength(); i++) {
            Node node = nList.item(i);
            Element eElement = (Element) node;
            String cveId = eElement.getElementsByTagName("title").item(0).getTextContent();
            Vulnerability vulnOVAL = new Vulnerability(cveId);
            String date = null;
            String description = null;
            if (eElement.getElementsByTagName("debian").getLength() > 0) {
                if (eElement.getElementsByTagName("date").getLength() > 0) {
                    date = eElement.getElementsByTagName("date").item(0).getTextContent();
                    vulnOVAL.setPublishedDate(date);
                }
                if (eElement.getElementsByTagName("moreinfo").getLength() > 0) {
                    description = eElement.getElementsByTagName("moreinfo").item(0).getTextContent();
                    vulnOVAL.setDescription(description);
                }
            }
            // Grab all test_ref in criterion
            NodeList criteriaList = eElement.getElementsByTagName("criterion");
            for (int j = 0; j < criteriaList.getLength(); j++) {
                Element criteria = (Element) criteriaList.item(j);
                String testRef = criteria.getAttribute("test_ref");
                // ovalTests 1 and 2 contain info about architecture and distro
                // TODO: Include this information into purl
                if (!testRef.equals("oval:org.debian.oval:tst:1") &&
                        !testRef.equals("oval:org.debian.oval:tst:2")) {
                    Pair<String, String> ovalTestInfo = ovalTestMap.get(testRef);
                    String productName = ovalObjectMap.get(ovalTestInfo.getFirst());
                    String lessThanVersion = ovalStateMap.get(ovalTestInfo.getSecond()).substring(2);
                    // Build version range that includes the vulnerable versions
                    List<String> allVersions = versionRanger.getVersions("/deb/debian/" + productName);
                    logger.info("Retrieved " + allVersions.size() +" versions of pgk:deb/debian/" + productName);
                    List<String> vulnerableVersions = versionRanger.getVulnerableVersionsOVAL(lessThanVersion,
                            allVersions);
                    for (String v : vulnerableVersions) {
                        // For now, we only handle buster distro
                        vulnOVAL.addPurl("pgk:deb/debian/" + productName + "@" + v + "?distro=buster");
                    }
                }
                vulnerabilities.put(vulnOVAL.getId(), vulnOVAL);
            }
        }
        return vulnerabilities;
    }

    @Override
    public HashMap<String, Vulnerability> getUpdates() {
        // We cannot get only diff files of the two OVALs
        // Therefore, we parse it all again
        return getVulnerabilities();
    }

    public static void main(String[] args) {
        JavaHttpClient client = new JavaHttpClient();
        VersionRanger vr = new VersionRanger(client, "./analyzer/vulnerability-plugin/src/main/resources/trackers/package_versions.json");
        OVALParser op = new OVALParser(client, vr);

        long startTime = System.nanoTime();

        HashMap<String, Vulnerability> vulns = op.getVulnerabilities();

        for (String key : vulns.keySet()) {
            System.out.println("FOUND " + vulns.get(key).getId());
        }

        long elapsedTime = System.nanoTime() - startTime;

        System.out.println("Total execution time to create 1000K objects in Java in millis: "
                + elapsedTime/1000000);
    }
}
