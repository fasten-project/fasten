/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.analyzer.vulnerabilityplugin.utils.parsers;

import java.io.*;
import java.net.MalformedURLException;
import java.net.URL;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Properties;
import java.util.concurrent.TimeUnit;
import java.util.zip.GZIPInputStream;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import eu.fasten.analyzer.vulnerabilityplugin.utils.Vulnerability;
import eu.fasten.analyzer.vulnerabilityplugin.utils.connections.JavaHttpClient;
import eu.fasten.analyzer.vulnerabilityplugin.utils.mappers.Severity;
import org.jooq.tools.json.JSONParser;
import org.owasp.dependencycheck.data.nvd.json.DefCpeMatch;
import org.owasp.dependencycheck.data.nvd.json.DefCveItem;
import org.owasp.dependencycheck.data.nvd.json.DefNode;
import org.owasp.dependencycheck.data.nvd.json.Reference;
import org.owasp.dependencycheck.utils.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


import static java.nio.charset.StandardCharsets.UTF_8;

public class NVDParser implements VulnerabilityParser {

    public static JSONParser jsonParser;
    public static JavaHttpClient client;
    public static Downloader downloader;
    private final Logger logger = LoggerFactory.getLogger(NVDParser.class.getName());

    public NVDParser(JSONParser jsonParser, JavaHttpClient client) {
        this.client = client;
        this.jsonParser = jsonParser;
    }

    /**
     * Unzip and Parsing of NVD Json information.
     *
     * @param gzip File with path pointing to the GZIP file
     *             e.g. File raw = new File("./analyzer/vulnerability-plugin/src/main/resources/nvdcve-1.1-2005.json.gz");
     * @return List of Vulnerabilities parsed
     * @throws IOException in the case where the file is not a zip file
     */
    public List<DefCveItem> parseCVEZip(File gzip) throws IOException {

        List<DefCveItem> cves = new ArrayList<>();

        InputStream fin = new FileInputStream(gzip);
        InputStream in = new GZIPInputStream(fin);
        InputStreamReader isr = new InputStreamReader(in, UTF_8);
        JsonReader reader = new JsonReader(isr);

        final Gson gson = new GsonBuilder().create();
        reader.beginObject();

        while (reader.hasNext() && !JsonToken.BEGIN_ARRAY.equals(reader.peek())) {
            reader.skipValue();
        }
        reader.beginArray();
        while (reader.hasNext()) {
            cves.add(gson.fromJson(reader, DefCveItem.class));
        }
        return cves;
    }

    /**
     * Downloads CVE json Data Feed from 2002 until current year.
     *
     * @return a list of the paths where the gzip files are stored.
     * @throws MalformedURLException     - URL is not accessible
     * @throws TooManyRequestsException  - too many requests are performed
     * @throws DownloadFailedException   - download fails
     * @throws ResourceNotFoundException - resource cannot be found
     */
    public List<File> downloadCVEs() throws MalformedURLException,
            TooManyRequestsException,
            DownloadFailedException,
            ResourceNotFoundException {
        int currentYear = LocalDate.now().getYear();
        List<File> paths = new ArrayList<>();
        for (int i = 2002; i <= currentYear; i++) {
            URL cve_url = new URL("https://nvd.nist.gov/feeds/json/cve/1.1/nvdcve-1.1-" + i + ".json.gz");
            File out_path = new File("./analyzer/vulnerability-plugin/src/main/resources/nvd/nvdcve-1.1-" + i + ".json.gz");
            downloader.fetchFile(cve_url, out_path);
            paths.add(out_path);
        }
        return paths;
    }

    /**
     * Downloads updates from NVD JSON Data Feed.
     *
     * @return Path to the saved file
     * @throws MalformedURLException     - URL is not accessible
     * @throws TooManyRequestsException  - too many requests are performed
     * @throws DownloadFailedException   - download fails
     * @throws ResourceNotFoundException - resource cannot be found
     */
    public File downloadUpdates() throws MalformedURLException,
            TooManyRequestsException,
            DownloadFailedException,
            ResourceNotFoundException {
        URL updates_url = new URL("https://nvd.nist.gov/feeds/json/cve/1.1/nvdcve-1.1-modified.json.gz");
        File out_path = new File("./analyzer/vulnerability-plugin/src/main/resources/nvd/nvdcve-1.1-modified.json.gz");
        downloader.fetchFile(updates_url, out_path);
        return out_path;
    }

    /**
     * Parses cpe23Uri String extracting necessary information.
     *
     * @param vulnerability - Vulnerability Object to inject cpe23Uri
     * @param cpe23Uri      - String to parse
     */
    public void injectCpeInfo(Vulnerability vulnerability, String cpe23Uri) {
        String[] data = cpe23Uri.split(":");
        String vendor = data[3];
        String product = data[4];
        String version = data[5];

        // Add Cpe23Uri to Vulnerability Object
        vulnerability.addCpeUri(new Vulnerability.Cpe23Uri(vendor, product, version));
    }

    /**
     * Extracts information from each DefCveItem and inject it into Vulnerability Objects
     *
     * @param cveItem - see DefCveItem class for more information
     * @return the parsed and enriched vulnerability
     */
    public Vulnerability parseVulnerability(DefCveItem cveItem) {
        Vulnerability vulnerability = new Vulnerability(cveItem.getCve().getCVEDataMeta().getId());
        logger.info("Parsing Vulnerability with ID - " + vulnerability.getId());
        vulnerability.setDescription(cveItem.getCve().getDescription().getDescriptionData().get(0).getValue());
        if (cveItem.getImpact().getBaseMetricV2() != null) {
            vulnerability.setScoreCVSS2(cveItem.getImpact().getBaseMetricV2().getCvssV2().getBaseScore());
            vulnerability.setSeverity(Severity.valueOf(cveItem.getImpact().getBaseMetricV2().getSeverity()));
        }
        if (cveItem.getImpact().getBaseMetricV3() != null) {
            vulnerability.setScoreCVSS3(cveItem.getImpact().getBaseMetricV3().getCvssV3().getBaseScore());
        }
        vulnerability.setPublishedDate(cveItem.getPublishedDate());
        vulnerability.setLastModifiedDate(cveItem.getLastModifiedDate());
        for (DefNode node : cveItem.getConfigurations().getNodes()) {
            for (DefCpeMatch match : node.getCpeMatch()) {
                injectCpeInfo(vulnerability, match.getCpe23Uri());
            }
        }
        // Adding Patch links, Exploit links or other references
        for (Reference ref : cveItem.getCve().getReferences().getReferenceData()) {
            if (ref.getTags().contains("Exploit")) {
                vulnerability.addExploit(ref.getUrl());
            } else if (ref.getTags().contains("Patch")) {
                vulnerability.addPatch(ref.getUrl());
            } else {
                vulnerability.addReference(ref.getUrl());
            }
        }

        return vulnerability;
    }

    /**
     * Helper function for the vulnerability Plugin to inject the sleep behaviour.
     * This way, when mocking the parser, you can just skip over the wait.
     */
    public void sleep() {
        try {
            TimeUnit.DAYS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    /**
     * Retrieves all vulnerabilities from NVD
     *
     * @return - map of the vulnerabilities ready to be merged.
     */
    public HashMap<String, Vulnerability> getVulnerabilities() {
        HashMap<String, Vulnerability> vulnerabilities = new HashMap<>();
        List<File> paths = null;
        try {
            // Facilitates testing since you inject it beforehand
            if (this.downloader == null) {
                this.downloader = new Downloader(new Settings(new Properties()));
            }
            paths = downloadCVEs();
        } catch (MalformedURLException e) {
            e.printStackTrace();
        } catch (TooManyRequestsException e) {
            e.printStackTrace();
        } catch (DownloadFailedException e) {
            e.printStackTrace();
        } catch (ResourceNotFoundException e) {
            e.printStackTrace();
        }
        List<DefCveItem> rawCves = new ArrayList<>();
        for (File path : paths) {
            try {
                rawCves.addAll(parseCVEZip(path));
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        for (DefCveItem item : rawCves) {
            Vulnerability v = parseVulnerability(item);
            vulnerabilities.put(v.getId(), v);
        }

        logger.info("Parsed " + vulnerabilities.size() + " vulnerabilities from NVD");
        return vulnerabilities;
    }

    /**
     * Method downloads daily updates from NVD and returns a Hash-Map of it.
     *
     * @return - map of the new vulnerabilities
     */
    public HashMap<String, Vulnerability> getUpdates() {
        HashMap<String, Vulnerability> vulnerabilities = new HashMap<>();
        File pathToUpdates = null;
        try {
            if (this.downloader == null) {
                this.downloader = new Downloader(new Settings(new Properties()));
            }
            pathToUpdates = downloadUpdates();
        } catch (MalformedURLException e) {
            e.printStackTrace();
        } catch (TooManyRequestsException e) {
            e.printStackTrace();
        } catch (DownloadFailedException e) {
            e.printStackTrace();
        } catch (ResourceNotFoundException e) {
            e.printStackTrace();
        }
        List<DefCveItem> rawCves = new ArrayList<>();
        try {
            rawCves.addAll(parseCVEZip(pathToUpdates));
        } catch (IOException e) {
            e.printStackTrace();
        }
        for (DefCveItem item : rawCves) {
            Vulnerability v = parseVulnerability(item);
            vulnerabilities.put(v.getId(), v);
        }

        logger.info("Parsed " + vulnerabilities.size() + " vulnerabilities from NVD");
        return vulnerabilities;
    }
}
