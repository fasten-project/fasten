/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.analyzer.vulnerabilityplugin;

import com.google.gson.Gson;
import com.mongodb.client.MongoDatabase;
import eu.fasten.analyzer.vulnerabilityplugin.db.NitriteController;
import eu.fasten.analyzer.vulnerabilityplugin.utils.connections.JavaHttpClient;
import eu.fasten.analyzer.vulnerabilityplugin.utils.Vulnerability;
import eu.fasten.analyzer.vulnerabilityplugin.utils.parsers.ParserManager;
import eu.fasten.server.connectors.KafkaConnector;
import org.apache.commons.io.FileUtils;
import org.apache.kafka.clients.producer.KafkaProducer;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.json.JSONArray;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.*;

public class VulnerabilityPlugin {
    public static class VulnerabilityProducer {

        //        Kafka        //
        private List<String> serverAddresses;
        private String produceTopic = "fasten.vulnerability.out";
        private Throwable pluginError = null;
        private KafkaProducer<String, String> kafkaProducer;

        private ParserManager parserManager;
        private ProducerThread pt;
        private MongoDatabase mongoDatabase;
        protected static Queue<Vulnerability> queue = new LinkedList<>();
        private final Logger logger = LoggerFactory.getLogger(VulnerabilityProducer.class.getName());
        public boolean go = true;
        private final String pathToNitrite = "./analyzer/vulnerability-plugin/src/main/resources/nitrite/security.db";

        /**
         * Getter necessary to handle stopping of the Updater Thread
         *
         * @return ProducerThread Object that contains an UpdaterThread
         */
        public ProducerThread getProducerThread() {
            return pt;
        }

        /**
         * Setter helps with testing.
         * @param pt
         */
        public void setProducerThread(ProducerThread pt) {
            this.pt = pt;
        }

        public void setKafkaProducer(KafkaProducer<String, String> kafkaProducer) {
            this.kafkaProducer = kafkaProducer;
        }

        public static Queue<Vulnerability> getQueue() {
            return queue;
        }

        public void setServerAddresses(List<String> serverAddresses) {
            this.serverAddresses = serverAddresses;
        }

        public void setMongoDatabase(MongoDatabase mongoDatabase) {
            this.mongoDatabase = mongoDatabase;
        }

        public String name() {
            return "Vulnerability Plugin";
        }

        public String description() {
            return "Vulnerability plugin. "
                    + "Downloads CVE entries from the NVD Database, enriches"
                    + " them with method-level details and publishes to Kafka topic";
        }

        public String version() {
            return "1.0";
        }

        /**
         * Sets the connection to Mongodb instance.
         */
        public void createParserManager() {
            logger.info("Creating the ParserManager");
            JavaHttpClient client = new JavaHttpClient();
            NitriteController nc = new NitriteController(pathToNitrite);
            this.parserManager = new ParserManager(client, this.mongoDatabase, nc);
        }

        /**
         * Method to create a KafkaProducer in order to publish information
         * @return
         */
        public void createKafkaProducer() {
            Properties p = KafkaConnector.kafkaProducerProperties(this.serverAddresses, "vulnerability");
            this.kafkaProducer = new KafkaProducer<>(p);
        }

        /**
         * Helper method to inject the parser in the Plugin.
         * Facilitates testing.
         *
         * @param parser - parser to inject
         */
        public void injectParserManager(ParserManager parser) {
            this.parserManager = parser;
        }

        /**
         * Starting point of the plugin.
         * Sets up the ParserManager and the KafkaProducer.
         * Last, creates and starts the ProducerThread.
         */
        public void start() {
            createParserManager();
            pt = new ProducerThread(queue, parserManager);
            pt.start();

            while (go) {
                this.produce();
            }
        }

        /**
         * Looks into the queue and produces to the topic if it finds something.
         */
        public void produce() {
            while (queue.isEmpty()) {
                // do nothing, waiting for the queue to get some elements
            }
            // Poll it and inject in the DB
            Vulnerability v = queue.poll();
            ProducerRecord<String, String> record = new ProducerRecord<>("vulnerability_producer", v.toJson());
            kafkaProducer.send(record);
        }

        /**
         * Reads vulnerabilities from a JSON file.
         * Used for the demo
         * @param jsonPath - Path to JSON file
         * @return List of vulnerabilities
         */
        public static List<Vulnerability> getVulnerabilitiesFromJson(String jsonPath) {
            List<Vulnerability> vulns = new ArrayList<>();
            // Read the content from the file
            File file = new File(jsonPath);
            String raw = null;
            try {
                raw = FileUtils.readFileToString(file, StandardCharsets.UTF_8);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (raw == null) return vulns;
            // Parse the JSON
            JSONArray vulnArray = new JSONArray(raw);
            Gson gson = new Gson();
            for (int i = 0; i < vulnArray.length(); i++) {
                var v = gson.fromJson(vulnArray.getJSONObject(i).toString(), Vulnerability.class);
                vulns.add(v);
            }
            return vulns;
        }
    }

    static class ProducerThread implements Runnable {

        Thread thread;
        Logger logger = LoggerFactory.getLogger(getClass());
        Queue<Vulnerability> queue;
        ParserManager parser;
        UpdaterThread ut;

        public ProducerThread(Queue<Vulnerability> queue, ParserManager parser) {
            this.queue = queue;
            this.parser = parser;
        }

        public UpdaterThread getUpdater() {
            return ut;
        }

        public void start() {
            logger.info("Started ProducerThread");
            thread = new Thread(this);
            thread.start();
        }

        @Override
        public void run() {
            // Get all the vulnerabilities from the Parsers and enqueue them
            logger.info("Gathering information from all parsers");
            HashSet<Vulnerability> vulnerabilities = parser.getVulnerabilitiesFromParsers();
            logger.info("Received a total of " + vulnerabilities.size() + " vulnerabilities from the ParserManager.");
            for (Vulnerability v : vulnerabilities) {
                // Add it to the queue to publish to Kafka
                queue.add(v);
            }

            // Start a new Thread that checks
            // for updates every day and writes new vulnerabilities
            logger.info("Starting the Updater Thread");
            ut = new UpdaterThread(queue, parser);
            ut.start();
        }
    }

    static class UpdaterThread implements Runnable {

        Thread thread;
        Queue<Vulnerability> queue;
        ParserManager parser;
        Logger logger = LoggerFactory.getLogger(getClass());
        private volatile boolean exit = false;

        public UpdaterThread(Queue<Vulnerability> queue, ParserManager parser) {
            this.queue = queue;
            this.parser = parser;
        }

        public void start() {
            thread = new Thread(this);
            thread.start();
        }

        public void terminate() {
            exit = true;
        }

        @Override
        public void run() {
            while (!exit) {
                try {
                    // Step 1: Sleep for a day
                    // Injected into parser logic in order to test
                    parser.sleep();

                    // Get updates and inject them as well
                    HashSet<Vulnerability> updates = parser.getUpdatesFromParsers();
                    for (Vulnerability v : updates) {
                        queue.add(v);
                    }
                } catch (Exception e) {
                    System.out.println("Could not run updater");
                }
            }
        }
    }
}


