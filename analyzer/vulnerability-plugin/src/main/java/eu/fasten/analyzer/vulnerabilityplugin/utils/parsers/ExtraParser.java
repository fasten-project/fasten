/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.analyzer.vulnerabilityplugin.utils.parsers;

import com.opencsv.CSVReader;
import eu.fasten.analyzer.vulnerabilityplugin.utils.Vulnerability;
import eu.fasten.analyzer.vulnerabilityplugin.utils.connections.JavaHttpClient;
import eu.fasten.analyzer.vulnerabilityplugin.utils.mappers.VersionRanger;
import eu.fasten.analyzer.vulnerabilityplugin.utils.mappers.YAMLHandler;
import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.api.errors.GitAPIException;

import org.json.JSONArray;
import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.yaml.snakeyaml.Yaml;
import org.yaml.snakeyaml.constructor.Constructor;
import org.apache.commons.io.FileUtils;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;

public class ExtraParser implements VulnerabilityParser {

    private HashMap<String, Vulnerability> vulnerabilities;
    private JavaHttpClient client;
    private VersionRanger versionRanger;
    private final Logger logger = LoggerFactory.getLogger(ExtraParser.class.getName());

    /**
     * The same client is injected in both ExtraParser and the VersionRanger.
     * This will help with Mocking when testing later.
     *
     * @param client - JavaHttpClient
     */
    public ExtraParser(JavaHttpClient client, VersionRanger versionRanger) {
        this.vulnerabilities = new HashMap<>();
        this.versionRanger = versionRanger;
        this.client = client;
    }

    public VersionRanger getVersionRanger() {
        return versionRanger;
    }

    public HashMap<String, Vulnerability> getVulnerabilitiesInMemory() {
        return vulnerabilities;
    }

    /**
     * Injects information in the dictionary from the dataset provided by pyupio on Github.
     * Find more information here: https://github.com/pyupio/safety-db
     * The JSON Feed is updated monthly.
     */
    public void injectFromSafetyDB() {
        try {
            String insecureJson = client.sendGet("https://raw.githubusercontent.com/pyupio/safety-db/master/data/insecure_full.json");

            JSONObject jsonObject = new JSONObject(insecureJson.trim());
            Iterator<String> keys = jsonObject.keys();

            while (keys.hasNext()) {
                String key = keys.next();
                JSONArray listVulns = (JSONArray) jsonObject.get(key);
                Iterator<Object> vulnIterator = listVulns.iterator();
                while (vulnIterator.hasNext()) {
                    JSONObject vulnObject = (JSONObject) vulnIterator.next();
                    var cveIds = vulnObject.get("cve");
                    if (!cveIds.toString().equals("null")) {
                        // There are multiple CVE-IDs
                        if (cveIds.toString().contains(",")) {
                            String[] cves = cveIds.toString().split(",\\s?");
                            for (String cve : cves) {
                                Vulnerability parsedVuln = injectInfoHelper(key, cve, vulnObject);
                                insertVulnerability(parsedVuln);
                            }
                        } else {
                            // There is only one CVE-ID
                            var cveId = cveIds;
                            Vulnerability parsedVuln = injectInfoHelper(key, cveId.toString(), vulnObject);
                            insertVulnerability(parsedVuln);
                        }
                    } else {
                        // There is only PyUp-id
                        String pyupId = (String) vulnObject.get("id");
                        Vulnerability parsedVuln = injectInfoHelper(key, pyupId, vulnObject);
                        insertVulnerability(parsedVuln);
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Looks for a vulnerability that was already in the map.
     * If found, it updates it, else puts a new entry.
     *
     * @param v - Vulnerability to insert in the map.
     */
    private void insertVulnerability(Vulnerability v) {
        logger.info("Parsed Vulnerability with ID - " + v.getId());
        if (vulnerabilities.get(v.getId()) == null) {
            vulnerabilities.put(v.getId(), v);
        } else {
            Vulnerability existing = vulnerabilities.get(v.getId());
            existing.merge(v);
            vulnerabilities.put(v.getId(), existing);
        }
    }

    /**
     * Takes a CVE-ID and a JSONObject from safetydb specification and injects information in the dictionary.
     *
     * @param packageName - name of the package to retrieve vulnerable versions from.
     * @param id          - id of the vulnerability
     * @param vulnObject  - JSON Object containing the information related to the package and its vulnerabilities.
     */
    private Vulnerability injectInfoHelper(String packageName, String id, JSONObject vulnObject) {
        Vulnerability v = new Vulnerability(id);
        v.setDescription((String) vulnObject.get("advisory"));
        List<String> versionsPgk = versionRanger.getVersions("/pypi/" + packageName);
        String[] ranges = vulnObject.get("v").toString().split(",");
        if (versionsPgk != null) {
            List<String> vulnerableVersions = versionRanger.getVulnerableVersionsJSON(ranges, versionsPgk);
            for (String vulnerableVersion : vulnerableVersions) {
                v.addPurl("pgk:pypi/" + packageName + "@" + vulnerableVersion);
            }
        }
        return v;
    }

    /**
     * This method can pull information from https://github.com/fabric8-analytics/cvedb
     * and https://github.com/victims/victims-cve-db
     * The bot that creates PRs is by far the best mapper between NVD and package coordinates.
     * Unfortunately, the repo is not very maintained and that means PRs are not merged so often.
     * Example of inputs:
     * https://github.com/victims/victims-cve-db.git
     * https://github.com/fabric8-analytics/cvedb.git
     */
    public void injectYAMLSource(String repoUrl) {
        String repoName = repoUrl.split("/")[4].split("\\.")[0];
        String cloneDirectoryPath = "./analyzer/vulnerability-plugin/src/main/resources/datasets/" + repoName;
        File checkDirAlreadyExists = new File(cloneDirectoryPath);
        if (checkDirAlreadyExists.exists()) {
            try {
                FileUtils.deleteDirectory(new File(cloneDirectoryPath));
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        try {
            // Step 1: Clone the repo
            Git git = Git.cloneRepository()
                    .setURI(repoUrl)
                    .setDirectory(Paths.get(cloneDirectoryPath).toFile())
                    .call();
            // Step 2: Parse the information in the repo
            parseYAMLInformation(cloneDirectoryPath);
        } catch (GitAPIException e) {
            e.printStackTrace();
        }
    }

    /**
     * Helper function to Parse YAML format information
     *
     * @param cloneDirectoryPath
     */
    public void parseYAMLInformation(String cloneDirectoryPath) {
        // Parse Java Database
        Yaml javaYaml = new Yaml(new Constructor(YAMLHandler.JavaVulnMapper.class));
        String[] years = new File(cloneDirectoryPath + "/database/java").list();
        for (String year : years) {
            try {
                String pathToYearDir = cloneDirectoryPath + "/database/java/" + year;
                Set<String> files = listFilesUsingDirectoryStream(pathToYearDir);
                for (String file : files) {
                    logger.info("Parsing java statement file " + file + " from year " + year);
                    String content = Files.readString(Paths.get(pathToYearDir + "/" + file));
                    YAMLHandler.JavaVulnMapper javaPgk = javaYaml.load(content);
                    // Check if you already have versions from the VersionRanger
                    List<String> versionsPgk = versionRanger.getVersions("/maven/" +
                            javaPgk.affected.get(0).groupId + "/" +
                            javaPgk.affected.get(0).artifactId);
                    // Find vulnerable versions and create purls in the mappings
                    List<String> vulnerableVersions = versionRanger.getVulnerableVersionsYAML(javaPgk.affected.get(0).version, versionsPgk);
                    HashSet<String> vulnerablePURL = versionRanger.buildPURLSMaven(javaPgk.affected.get(0), vulnerableVersions);
                    Vulnerability v = YAMLHandler.buildJavaVulnerabilityFromYaml(javaPgk, vulnerablePURL);
                    insertVulnerability(v);
                }
            } catch (IOException e) {
                System.out.println("Could not list any files for year: " + year);
            }
        }
        // Parse Python Database
        Yaml pythonYaml = new Yaml(new Constructor(YAMLHandler.PythonVulnMapper.class));
        String[] yearsPython = new File(cloneDirectoryPath + "/database/python").list();
        for (String year : yearsPython) {
            try {
                String pathToYearDir = cloneDirectoryPath + "/database/python/" + year;
                Set<String> files = listFilesUsingDirectoryStream(pathToYearDir);
                for (String file : files) {
                    logger.info("Parsing python statement file " + file + " from year " + year);
                    String content = Files.readString(Paths.get(pathToYearDir + "/" + file));
                    YAMLHandler.PythonVulnMapper pythonPgk = pythonYaml.load(content);
                    // Check if you already have versions from the VersionRanger
                    List<String> versionsPgk = versionRanger.getVersions("/pypi/" + pythonPgk.affected.get(0).name);
                    // Find vulnerable versions and create purls in the mappings
                    List<String> vulnerableVersions = versionRanger.getVulnerableVersionsYAML(pythonPgk.affected.get(0).version, versionsPgk);
                    HashSet<String> vulnerablePURL = versionRanger.buildPURLSPypi(pythonPgk.affected.get(0), vulnerableVersions);
                    Vulnerability v = YAMLHandler.buildPythonVulnerabilityFromYaml(pythonPgk, vulnerablePURL);
                    insertVulnerability(v);
                }
            } catch (IOException e) {
                System.out.println("Could not list any files for year: " + year);
            }
        }
    }

    /**
     * Helper function to get all the files in a directory.
     *
     * @param dir path to the directory to list files
     * @return Set of Strings where each string is a file name of a YAML file with a vulnerability
     * @throws IOException
     */
    public Set<String> listFilesUsingDirectoryStream(String dir) throws IOException {
        Set<String> fileList = new HashSet<>();
        try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(dir))) {
            for (Path path : stream) {
                if (!Files.isDirectory(path)) {
                    if (!path.getFileName().toString().equals(".gitkeep")) {
                        fileList.add(path.getFileName()
                                .toString());
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return fileList;
    }

    /**
     * Parses all the additional files in the resources/datasets folder.
     * https://github.com/SAP/project-kb/blob/master/MSR2019/dataset/vulas_db_msr2019_release.csv
     */
    public void injectExtraCommits() {
        try {
            String extraCommitsCsv = client.sendGet("https://raw.githubusercontent.com/SAP/project-kb/master/MSR2019/dataset/vulas_db_msr2019_release.csv");
            try {
                CSVReader reader = new CSVReader(new StringReader(extraCommitsCsv));
                String[] line;
                while ((line = reader.readNext()) != null) {
                    String cveId = line[0];
                    String commitUrl = line[1] + "/commit/" + line[2];
                    Vulnerability v = new Vulnerability(cveId);
                    v.addPatch(commitUrl);
                    insertVulnerability(v);
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void injectDebianOVAL() {
        // TODO: Parse Debian OVAL
        // Find more info here: https://www.debian.org/security/oval/
    }

    /**
     * This method injects into the vulnerabilities of the ExtraParser.
     * Taking information from the MSR2020 dataset collection.
     * @param datasetPath - String of the path to look where to download/read data
     * "./analyzer/vulnerability-plugin/src/main/resources/datasets/all_c_cpp_release2.0.csv"
     */
    public void injectMSR2020CPP(String datasetPath) {
        File datasetFile = new File(datasetPath);
        String data = null;
        if (datasetFile.exists()) {
            try {
                data = FileUtils.readFileToString(datasetFile, StandardCharsets.UTF_8);
                logger.info("Found MSR2020 CPP dataset from memory");
            } catch (IOException e) {
                logger.error("Error while loading MSR2020 CPP file from memory");
                e.printStackTrace();
            }
        } else {
            // Download raw content
            try {
                logger.info("Downloading raw CSV file from MSR2020");
                data = client.sendGet("https://raw.githubusercontent.com/ZeoVan/MSR_20_Code_vulnerability_CSV_Dataset/master/all_c_cpp_release2.0.csv");
                try (PrintWriter out = new PrintWriter(datasetPath)) {
                    if (data != null) {
                        logger.info("Writing dataset to memory");
                        out.write(data);
                    }
                } catch (FileNotFoundException e) {
                    logger.error("Error while writing the dataset to memory");
                    e.printStackTrace();
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        // Parse the data
        try {
            FileReader filereader = new FileReader(datasetPath);
            CSVReader csvReader = new CSVReader(filereader);
            String[] nextRecord;
            int counter = 0;
            int refcount = 0;

            // Parses line by line (first is header, so we skip it)
            while ((nextRecord = csvReader.readNext()) != null) {
                if (nextRecord.length > 14 && counter > 0) {
                    if (nextRecord[14].startsWith("https://")) {
                        // Create a new vulnerability with the information
                        Vulnerability v = new Vulnerability(nextRecord[3]);
                        v.setDescription(nextRecord[11]);
                        v.setLastModifiedDate(nextRecord[12]);
                        v.addPatch(nextRecord[14]);
                        refcount += 1;
                        insertVulnerability(v);
                    }
                }
                counter += 1;
            }

            logger.info("Found a total of " + refcount + " vulnerability in the CPP dataset from MSR2020");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Looks at old and new ones and returns a hashmap of the changed or new ones parsed.
     *
     * @param oldVulnerabilities - map of old vulnerabilities
     * @param newVulnerabilities - map of new vulnerabilities containing (also) old
     * @return difference of the two
     */
    private HashMap<String, Vulnerability> getUpdatedVulnerabilities(HashMap<String, Vulnerability> oldVulnerabilities,
                                                                     HashMap<String, Vulnerability> newVulnerabilities) {
        for (String id : newVulnerabilities.keySet()) {
            if (oldVulnerabilities.get(id) != null) {
                if (oldVulnerabilities.get(id).equals(newVulnerabilities.get(id))) {
                    newVulnerabilities.remove(id);
                }
            }
        }

        logger.info("Parsed " + newVulnerabilities.size() + " from ExtraSources");
        return newVulnerabilities;
    }

    /**
     * Method that injects everything and returns the HashMap with the Vulnerabilities.
     *
     * @return hashmap of vulnerabilities
     */
    public HashMap<String, Vulnerability> getVulnerabilities() {
        logger.info("Parsing database from Safety-DB");
        injectFromSafetyDB();
        logger.info("Injecting extra commits from MSR2019");
        injectExtraCommits();
        logger.info("Parsing database from cvedb");
        injectYAMLSource("https://github.com/edoardolanzini/cvedb.git");
        logger.info("Parsing database from victims-cve-db");
        injectYAMLSource("https://github.com/victims/victims-cve-db.git");

        logger.info("Parsed " + vulnerabilities.size() + " vulnerabilities from Extra Sources");
        return vulnerabilities;
    }

    public HashMap<String, Vulnerability> getUpdates() {
        HashMap<String, Vulnerability> oldVulnerabilities = (HashMap<String, Vulnerability>) vulnerabilities.clone();
        logger.info("Parsing database from Safety-DB");
        injectFromSafetyDB();
        logger.info("Parsing database from cvedb");
        injectYAMLSource("https://github.com/edoardolanzini/cvedb.git");
        logger.info("Parsing database from victims-cve-db");
        injectYAMLSource("https://github.com/victims/victims-cve-db.git");
        return getUpdatedVulnerabilities(oldVulnerabilities, vulnerabilities);
    }
}