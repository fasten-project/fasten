/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.analyzer.vulnerabilityplugin.parsers;

import eu.fasten.analyzer.vulnerabilityplugin.utils.Vulnerability;
import eu.fasten.analyzer.vulnerabilityplugin.utils.connections.JavaHttpClient;
import eu.fasten.analyzer.vulnerabilityplugin.utils.mappers.VersionRanger;
import eu.fasten.analyzer.vulnerabilityplugin.utils.parsers.ExtraParser;
import org.apache.commons.io.FileUtils;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.List;

import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.when;

public class ExtraParserTest {

    JavaHttpClient clientMock = Mockito.mock(JavaHttpClient.class);
    ExtraParser extraParser = new ExtraParser(clientMock, new VersionRanger(clientMock, "./analyzer/vulnerability-plugin/src/main/resources/trackers/package_versions.json"));

    String extraCommits = "CVE-2017-4971,https://github.com/spring-projects/spring-webflow,57f2ccb66946943fbf3b3f2165eac1c8eb6b1523,pos\n" +
            "CVE-2018-1000134,https://github.com/pingidentity/ldapsdk,8471904a02438c03965d21367890276bc25fa5a6,pos";

    String mockCSV = ",authentication_required,availability_impact,cve_id," +
            "cve_page,cwe_id,access_complexity,confidentiality_impact,integrity_impact," +
            "publish_date,score,summary,update_date,vulnerability_classification,ref_link," +
            "commit_id,commit_message,files_changed,lang,project,version_after_fix,version_before_fix\n" +
            "0,Not required,Partial,CVE-2009-1194," +
            "https://www.cvedetails.com/cve/CVE-2009-1194/,CWE-189,Medium,Partial,Partial,2009-05-11,6.8," +
            "\"Description of vulnerability.\"," +
            "2018-10-10,DoS Exec Code Overflow ," +
            "https://github.com/bratsche/pango/commit/4de30e5500eaeb49f4bf0b7a07f718e149a2ed5e,4de30e5500eaeb49f4bf0b7a07f718e149a2ed5e," +
            "[glyphstring] Handle overflow with very long glyphstrings";

    String insecureJsonMock;

    {
        try {
            insecureJsonMock = FileUtils.readFileToString(new File("./src/test/resources/parsers/insecureMock.json"), StandardCharsets.UTF_8);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Test
    public void testInjectExtraCommits() throws Exception {
        when(clientMock.sendGet("https://raw.githubusercontent.com/SAP/project-kb/master/MSR2019/dataset/vulas_db_msr2019_release.csv")).thenReturn(extraCommits);

        extraParser.injectExtraCommits();

        assertTrue(extraParser.getVulnerabilitiesInMemory().containsKey("CVE-2017-4971"));
        assertTrue(extraParser.getVulnerabilitiesInMemory().get("CVE-2017-4971").getPatches().contains("https://github.com/spring-projects/spring-webflow/commit/57f2ccb66946943fbf3b3f2165eac1c8eb6b1523"));

        assertTrue(extraParser.getVulnerabilitiesInMemory().containsKey("CVE-2018-1000134"));
        assertTrue(extraParser.getVulnerabilitiesInMemory().get("CVE-2018-1000134").getPatches().contains("https://github.com/pingidentity/ldapsdk/commit/8471904a02438c03965d21367890276bc25fa5a6"));
    }

    @Test
    public void testInjectFromSafetyDB() throws Exception {
        List<String> mockVersions = Arrays.asList("0.9", "1.0", "1.1", "1.2");
        extraParser.getVersionRanger().versionsMappings.put("/pypi/mock", mockVersions);

        when(clientMock.sendGet("https://raw.githubusercontent.com/pyupio/safety-db/master/data/insecure_full.json")).thenReturn(insecureJsonMock);

        extraParser.injectFromSafetyDB();

        Vulnerability v = new Vulnerability("mock-id");
        v.setDescription("mock description");
        v.addPurl("pgk:pypi/mock@0.9");
        v.addPurl("pgk:pypi/mock@1.0");

        assertTrue(extraParser.getVulnerabilitiesInMemory().get("mock-id").equals(v));

        Vulnerability v2 = new Vulnerability("CVE-TEST-1");
        v2.setDescription("mock description 2");
        v2.addPurl("pgk:pypi/mock@0.9");
        v2.addPurl("pgk:pypi/mock@1.0");

        assertTrue(extraParser.getVulnerabilitiesInMemory().get("CVE-TEST-1").equals(v2));

        Vulnerability v3 = new Vulnerability("CVE-TEST-2");
        v3.setDescription("mock description 3");
        v3.addPurl("pgk:pypi/mock@1.1");
        v3.addPurl("pgk:pypi/mock@1.2");

        assertTrue(extraParser.getVulnerabilitiesInMemory().get("CVE-TEST-2").equals(v3));

        Vulnerability v4 = new Vulnerability("CVE-TEST-3");
        v4.setDescription("mock description 3");
        v4.addPurl("pgk:pypi/mock@1.1");
        v4.addPurl("pgk:pypi/mock@1.2");

        assertTrue(extraParser.getVulnerabilitiesInMemory().get("CVE-TEST-3").equals(v4));
    }

    @Test
    public void testInjectYAMLSource() {
        extraParser.getVersionRanger().versionsMappings.put("/maven/org.mock/testing", Arrays.asList("2.0.0", "2.0.1.RELEASE"));
        extraParser.getVersionRanger().versionsMappings.put("/pypi/mock", Arrays.asList("0.2.2", "0.3.4"));

        Vulnerability vJava = new Vulnerability("CVE-2020-0001");
        vJava.setDescription("mock java");
        vJava.addReference("ref.com");
        vJava.setScoreCVSS2(7.5);
        vJava.addPurl("pgk:maven/org.mock/testing@2.0.1.RELEASE");

        Vulnerability vPython = new Vulnerability("CVE-2020-0002");
        vPython.setDescription("mock python");
        vPython.addReference("ref2.com");
        vPython.setScoreCVSS2(6.8);
        vPython.addPurl("pgk:pypi/mock@0.2.2");

        extraParser.parseYAMLInformation("./src/test/resources/parsers/yamlSource");

        assertTrue(extraParser.getVulnerabilitiesInMemory().get("CVE-2020-0001").equals(vJava));
        assertTrue(extraParser.getVulnerabilitiesInMemory().get("CVE-2020-0002").equals(vPython));
    }

    @Test
    public void testInjectMSR2020SaveFile() throws Exception {
        when(clientMock.sendGet("https://raw.githubusercontent.com/ZeoVan/MSR_20_Code_vulnerability_CSV_Dataset/master/all_c_cpp_release2.0.csv"))
                .thenReturn(mockCSV);
        String datasetPath = "./src/test/resources/parsers/msr2020_mock.csv";
        extraParser.injectMSR2020CPP(datasetPath);
        assertTrue(extraParser.getVulnerabilitiesInMemory().get("CVE-2009-1194")
                .getPatches().contains("https://github.com/bratsche/pango/commit/4de30e5500eaeb49f4bf0b7a07f718e149a2ed5e"));
        // Delete file that sits in memory
        File dataFile = new File(datasetPath);
        if (dataFile.exists()) {
            FileUtils.deleteQuietly(dataFile);
        }
    }


    @Test
    public void testInjectMSR2020FileInMemory() {
        String datasetPath = "./src/test/resources/parsers/msr2020_mock.csv";
        // Write the file to memory
        try (PrintWriter out = new PrintWriter(datasetPath)) {
            out.write(mockCSV);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
        // File is already in memory, so it should find it
        extraParser.injectMSR2020CPP(datasetPath);
        assertTrue(extraParser.getVulnerabilitiesInMemory().get("CVE-2009-1194")
                .getPatches().contains("https://github.com/bratsche/pango/commit/4de30e5500eaeb49f4bf0b7a07f718e149a2ed5e"));
        // Delete file at the end
        File dataFile = new File(datasetPath);
        if (dataFile.exists()) {
            FileUtils.deleteQuietly(dataFile);
        }
    }
}
