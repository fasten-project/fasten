package eu.fasten.analyzer.restapiplugin.mvn.api.impl;

import eu.fasten.analyzer.restapiplugin.mvn.KnowledgeBaseConnector;
import eu.fasten.analyzer.restapiplugin.mvn.LazyIngestionProvider;
import eu.fasten.analyzer.restapiplugin.mvn.api.VulnerabilityApiService;
import eu.fasten.core.data.Constants;
import org.json.JSONArray;
import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.util.List;

@Service
public class VulnerabilityApiServiceImpl implements VulnerabilityApiService {

    private final Logger logger = LoggerFactory.getLogger(getClass());

    @Override
    public ResponseEntity<String> getAllVulnerabilities(int offset, int limit, List<String> attributes) {
        var statements = KnowledgeBaseConnector.kbDao.getAllVulnerabilities(offset, limit);
        JSONArray vulnerabilities = new JSONArray(statements);
        var result = getStatementsAttributes(vulnerabilities, attributes)
                .toString().replace("\\/", "/");
        return new ResponseEntity<>(result, HttpStatus.OK);
    }

    @Override
    public ResponseEntity<String> getVulnerability(String externalId, List<String> attributes) {
        var statement = KnowledgeBaseConnector.kbDao.getVulnerability(externalId);
        if (statement == null) {
            return new ResponseEntity<>("Vulnerability not found", HttpStatus.NOT_FOUND);
        }
        JSONObject vulnerability = new JSONObject(statement);
        JSONObject needed = getStatementAttributes(vulnerability.getJSONObject("statement"), attributes);
        vulnerability.put("statement", needed);
        var result = vulnerability.toString().replace("\\/", "/");
        return new ResponseEntity<>(result, HttpStatus.OK);
    }

    @Override
    public ResponseEntity<String> getCoordinatesVulnerabilities(List<String> mavenCoordinates, List<String> attributes) {
        logger.info("Received a list of Maven coordinates");
        var jsonArray = new JSONArray();
        mavenCoordinates.stream().map(c -> {
            var package_name = c.split(Constants.mvnCoordinateSeparator)[0]
                    + Constants.mvnCoordinateSeparator
                    + c.split(Constants.mvnCoordinateSeparator)[1];
            var package_version = c.split(Constants.mvnCoordinateSeparator)[2];
            var vulnerabilities = "";
            if (!KnowledgeBaseConnector.kbDao.assertPackageExistence(package_name, package_version)) {
                try {
                    LazyIngestionProvider.ingestArtifactWithDependencies(package_name, package_version);
                    logger.info("Coordinate " + c + " not found, but should be processed soon. Try again later");
                } catch (Exception e) {
                    logger.info("Cannot find coordinate " + c + ": " +e.getMessage());
                }
            } else {
                var statements = KnowledgeBaseConnector.kbDao
                        .getPackageVersionVulnerabilities(package_name, package_version, false);
                JSONArray vul = new JSONArray(statements);
                vulnerabilities = getStatementsAttributes(vul, attributes).toString();
            }
            var json = new JSONObject();
            json.put(c, vulnerabilities);
            return json;
        }).forEach(jsonArray::put);
        var result = jsonArray.toString();
        result = result.replace("\\/", "/");
        return new ResponseEntity<>(result, HttpStatus.OK);
    }

    @Override
    public ResponseEntity<String> getPurls(String externalId, int offset, int limit) {
        var result = KnowledgeBaseConnector.kbDao.getPurls(externalId, offset, limit);
        if (result == null) {
            return new ResponseEntity<>("Vulnerability not found", HttpStatus.NOT_FOUND);
        }
        result = result.replace("\\/", "/");
        return new ResponseEntity<>(result, HttpStatus.OK);
    }

    @Override
    public ResponseEntity<String> getVulnerableCallables(String externalId, int offset, int limit) {
        var uriMap = KnowledgeBaseConnector.kbDao.getVulnerableCallables(externalId, offset, limit);
        if (uriMap == null) {
            return new ResponseEntity<>("Vulnerability not found", HttpStatus.NOT_FOUND);
        }
        var json = new JSONObject();
        uriMap.forEach((key, value) -> json.put(String.valueOf(key), value));
        var result = json.toString();
        result = result.replace("\\/", "/");
        return new ResponseEntity<>(result, HttpStatus.OK);
    }

    @Override
    public ResponseEntity<String> getPackageVersionVulnerabilities(String package_name, String package_version, List<String> attributes) {
        if (!KnowledgeBaseConnector.kbDao.assertPackageExistence(package_name, package_version)) {
            try {
                LazyIngestionProvider.ingestArtifactWithDependencies(package_name, package_version);
            } catch (IllegalArgumentException | IOException e) {
                return new ResponseEntity<>(e.getMessage(), HttpStatus.BAD_REQUEST);
            }
            return new ResponseEntity<>("Package version not found, but should be processed soon. Try again later", HttpStatus.CREATED);
        }
        var statements = KnowledgeBaseConnector.kbDao.getPackageVersionVulnerabilities(package_name, package_version, true);
        JSONArray vulnerabilities = new JSONArray(statements);
        var result = getStatementsAttributes(vulnerabilities, attributes)
                .toString().replace("\\/", "/");
        return new ResponseEntity<>(result, HttpStatus.OK);
    }

    @Override
    public ResponseEntity<String> getPurlVulnerabilities(String purl, List<String> attributes) {
        var packageVersionString = KnowledgeBaseConnector.kbDao.getPackageVersionString(purl);
        var package_name = packageVersionString.get(0);
        var package_version = packageVersionString.get(1);
        if (!KnowledgeBaseConnector.kbDao.assertPackageExistence(package_name, package_version)) {
            try {
                LazyIngestionProvider.ingestArtifactWithDependencies(package_name, package_version);
            } catch (IllegalArgumentException | IOException | IllegalStateException e ) {
                logger.warn(String.format("[%s] Cannot insert package version for '%s', root cause - %s",
                        HttpStatus.BAD_REQUEST, purl, e.getMessage()));
            }
        }
        var statements = KnowledgeBaseConnector.kbDao.getPurlVulnerabilities(purl, true);
        JSONArray vulnerabilities = new JSONArray((statements));
        var result = getStatementsAttributes(vulnerabilities, attributes)
                .toString().replace("\\/", "/");
        return new ResponseEntity<>(result, HttpStatus.OK);
    }

    private JSONObject getStatementAttributes(JSONObject statement, List<String> attributes) {
        var neededInfo = new JSONObject();
        if (attributes.size() > 0) {
            for (var attribute : statement.keySet()) {
                if (attributes.contains(attribute)) {
                    neededInfo.put(attribute, statement.get(attribute));
                }
            }
        } else {
            neededInfo = statement;
        }
        return neededInfo;
    }

    private JSONArray getStatementsAttributes(JSONArray statements, List<String> attributes) {
        JSONArray vulnInfo = new JSONArray();
        statements.forEach(v -> {
            JSONObject vJson = (JSONObject) v;
            JSONObject needed = getStatementAttributes(vJson.getJSONObject("statement"), attributes);
            vJson.put("statement", needed);
            vulnInfo.put(vJson);
        });
        return vulnInfo;
    }


}
