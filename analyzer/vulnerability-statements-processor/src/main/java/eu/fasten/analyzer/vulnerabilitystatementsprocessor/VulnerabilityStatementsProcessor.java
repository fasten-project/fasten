/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.analyzer.vulnerabilitystatementsprocessor;

import com.google.gson.Gson;
import eu.fasten.analyzer.vulnerabilitystatementsprocessor.db.MetadataUtility;
import eu.fasten.core.data.vulnerability.Vulnerability;
import eu.fasten.core.plugins.DBConnector;
import eu.fasten.core.plugins.KafkaPlugin;
import org.jooq.DSLContext;
import org.pf4j.Extension;
import org.pf4j.Plugin;
import org.pf4j.PluginWrapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.text.ParseException;
import java.util.*;

public class VulnerabilityStatementsProcessor extends Plugin {

    public VulnerabilityStatementsProcessor(PluginWrapper wrapper) {
        super(wrapper);
    }

    @Extension
    public static class VulnerabilityStatementsKafkaPlugin implements KafkaPlugin, DBConnector {
        private List<String> consumeTopics = new LinkedList<>(Collections.singletonList("fasten.Vulnerabilities.out"));
        private final String baseOutputPath = File.separator + "vulnerabilities" + File.separator + "processed_statements";
        private String outputPath;
        private static Map<String, DSLContext> contexts;
        private Exception pluginError = null;
        private Vulnerability lastProcessedVulnerability = null;
        private final Gson gson = new Gson();
        public final static String[] extensions = new String[]{".java", ".py", ".pyw", ".c", ".cpp", ".h"};
        private final static Logger logger = LoggerFactory.getLogger("VulnerabilityStatementsKafkaPlugin");

        @Override
        public void setDBConnection(Map<String, DSLContext> dslContexts) {
            contexts = dslContexts;
        }

        @Override
        public Optional<List<String>> consumeTopic() {
            return Optional.of(consumeTopics);
        }

        @Override
        public void setTopics(List<String> consumeTopics) {
            this.consumeTopics = consumeTopics;
        }

        @Override
        public void consume(String record) {
            this.pluginError = null;
            try {
                var vulnerability = gson.fromJson(record, Vulnerability.class);
                logger.info("Read vulnerability statement " + vulnerability.getId() + " from " + consumeTopics.toString());
                var metadataUtility = new MetadataUtility();
                lastProcessedVulnerability = insertVulnerability(vulnerability, metadataUtility);
                outputPath = baseOutputPath + File.separator + vulnerability.getId() + ".json";
            } catch (Exception e) {
                logger.error("Error processing vulnerability statement: " + e);
                setPluginError(e);
            }
        }

        @Override
        public Optional<String> produce() {
            if (lastProcessedVulnerability == null) {
                return Optional.empty();
            } else {
                return Optional.of(gson.toJson(lastProcessedVulnerability));
            }
        }

        @Override
        public String getOutputPath() {
            return outputPath;
        }

        @Override
        public String name() {
            return "Vulnerability Statements Processor";
        }

        @Override
        public String description() {
            return "Reads vulnerabilities from " + consumeTopics.toString() +
                    " and injects them in the database.";
        }

        @Override
        public String version() {
            return "0.0.1";
        }

        @Override
        public void start() {
        }

        @Override
        public void stop() {
        }

        @Override
        public Exception getPluginError() {
            return pluginError;
        }

        public void setPluginError(Exception throwable) {
            this.pluginError = throwable;
        }

        @Override
        public void freeResource() {
        }

        /**
         * Method to inject the information contained in a Vulnerability Object.
         *
         * @param v               - Vulnerability Object
         * @param metadataUtility - Metadata DAO
         */
        public Vulnerability insertVulnerability(Vulnerability v, MetadataUtility metadataUtility)  {
            var context = getDBContext(v);

            v.filterUnsupportedPatches(extensions);
            try {
                v.updatePatchDate();
            } catch (ParseException e) {
                logger.warn(v.getId() + ": Error updating patch date, continuing: " + e);
            }

            logger.info(v.getId() + ": Inserting vulnerability into the database for ecosystem " + "\"" + v.getEcosystem() + "\".");
            var vulnerabilityId = metadataUtility.insertVulnerability(v, context);
            v = updateCallablesAndPackageVersions(v, vulnerabilityId, metadataUtility);
            return v;
        }

        public Vulnerability updateCallablesAndPackageVersions(Vulnerability v, Long vulnerabilityId, MetadataUtility metadataUtility) {
            var context = getDBContext(v);
            var pkgIds = metadataUtility.getPackageIds(context, v.getValidatedPurls());
            if (pkgIds.size() == 0) {
                logger.info(v.getId() + ": No matching packages found in database.");
                return v;
            }

            var vulnerablePackageVersionIds = metadataUtility.getPackageVersionIds(v.getValidatedPurls(), context, pkgIds, v);
            if (vulnerablePackageVersionIds.size() == 0) {
                logger.info(v.getId() + ": No matching package-versions found in database.");
                return v;
            }

            var vulnerableFastenUris = new HashSet<String>();
            vulnerableFastenUris.addAll(findFastenUrisInLastVulnerableVersion(v, vulnerablePackageVersionIds, metadataUtility, context));
            vulnerableFastenUris.addAll(findFastenUrisInFirstPatchedVersion(v, pkgIds, metadataUtility, context));
            var vulnerableCallables = findVulnerableCallables(vulnerableFastenUris, vulnerablePackageVersionIds, metadataUtility, context);
            var vulnerableCallableIds = vulnerableCallables.keySet();
            v.setFastenUris(new HashSet<>(vulnerableCallables.values()));

            logger.info(v.getId() + ": Inserting data for " + vulnerablePackageVersionIds.size() + " vulnerable package-versions into the database.");
            vulnerablePackageVersionIds.forEach(id -> metadataUtility.injectPackageVersionVulnerability(v, id, context));
            metadataUtility.insertVulnerabilityToPackageVersions(vulnerabilityId, vulnerablePackageVersionIds, context);

            logger.info(v.getId() + ": Inserting data for " + vulnerableCallableIds.size() + " vulnerable callables into the database.");
            vulnerableCallableIds.forEach(id -> metadataUtility.injectCallableVulnerability(v, id, context));
            metadataUtility.insertVulnerabilityToCallables(vulnerabilityId, vulnerableCallableIds, context);
            return v;
        }

        public DSLContext getDBContext(Vulnerability v) {
            var ecosystem = v.getEcosystem();
            var context = ecosystem.equals("") ? null : contexts.get(ecosystem);
            if (context == null) {
                throw new UnsupportedOperationException(v.getId() + ": Malformed ecosystem data or unsupported ecosystem \"" + ecosystem + "\"");
            }
            return context;
        }

        HashSet<String> findFastenUrisInLastVulnerableVersion(Vulnerability v, List<Long> pkgVersionVulnIds, MetadataUtility metadataUtility, DSLContext context) {
            var lastVulnVersionId = pkgVersionVulnIds.get(pkgVersionVulnIds.size() - 1);
            var fastenUris = new HashSet<String>();
            v.getPatches().forEach(p -> {
                logger.info(v.getId() + ": Searching for callables in " + p.getFileName() + " for package-version: " + lastVulnVersionId);
                fastenUris.addAll(metadataUtility.getFastenUrisForPatch(p.getFileName(),
                        p.getOriginalChangedLineNumbers(),
                        lastVulnVersionId, context));
            });
            return fastenUris;
        }

        HashSet<String> findFastenUrisInFirstPatchedVersion(Vulnerability v, HashMap<String, Long> pkgIds, MetadataUtility metadataUtility, DSLContext context) {
            var firstPatchedVersionId = findFirstPatchedVersionId(v, pkgIds, metadataUtility, context);
            var fastenUris = new HashSet<String>();
            v.getPatches().forEach(p -> {
                logger.info(v.getId() + v.getId() + ": Searching for callables in " + p.getFileName() + " for package-version: " + firstPatchedVersionId);
                fastenUris.addAll(metadataUtility.getFastenUrisForPatch(p.getFileName(),
                        p.getNewChangedLineNumbers(),
                        firstPatchedVersionId, context));
            });
            return fastenUris;
        }

        Long findFirstPatchedVersionId(Vulnerability v, HashMap<String, Long> pkgIds, MetadataUtility metadataUtility, DSLContext context) {
            var pkgVersionPatchedIds = metadataUtility.getPackageVersionIds(v.getValidatedFirstPatchedPurls(), context, pkgIds, null);
            if (pkgVersionPatchedIds.size() > 0) {
                return pkgVersionPatchedIds.get(pkgVersionPatchedIds.size() - 1);
            } else {
                return -1L;
            }
        }

        HashMap<Long, String> findVulnerableCallables(HashSet<String> vulnerableFastenUris, List<Long> vulnPkgVersionIds, MetadataUtility metadataUtility, DSLContext context) {
            var vulnerableCallables = new HashMap<Long, String>();
            vulnerableFastenUris.forEach(uri -> {
                var callIds = metadataUtility.getCallableIdsForFastenUri(uri, new HashSet<>(vulnPkgVersionIds), context);
                callIds.forEach(id -> vulnerableCallables.put(id, metadataUtility.getFullFastenUri(uri, id)));
            });
            return vulnerableCallables;
        }
    }
}
