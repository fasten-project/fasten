/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.analyzer.vulnerabilityconsumer.db;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import eu.fasten.analyzer.vulnerabilityconsumer.utils.*;
import eu.fasten.core.data.Constants;
import eu.fasten.core.data.metadatadb.codegen.tables.*;
import eu.fasten.core.data.metadatadb.codegen.tables.records.CallablesRecord;
import eu.fasten.core.data.metadatadb.codegen.tables.records.PackageVersionsRecord;
import org.jooq.*;
import org.jooq.impl.DSL;
import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.*;
import java.net.*;
import java.util.*;
import java.util.function.UnaryOperator;
import java.util.stream.Collectors;

import static eu.fasten.core.data.Constants.fastenApiUrlDefault;
import static eu.fasten.core.data.Constants.fastenApiUrlEnvVariable;
import static eu.fasten.core.utils.FastenUriUtils.generateFullFastenUri;


public class MetadataUtility {

    private ObjectMapper objectMapper = new ObjectMapper();
    private Cache cache = new Cache();
    private UnaryOperator<String> getBasePurl = s -> s.split("@")[0];
    private final Logger logger = LoggerFactory.getLogger(MetadataUtility.class.getName());

    public MetadataUtility() {
    }

    public Cache getCache() {
        return cache;
    }

    /**
     * Looks for Unique Base PURLs and find the corresponding package ID.
     *
     * @param context - DSL Context
     * @param v       - Vulnerability Object
     * @return Map (basePURL --> pkgId)
     */
    public HashMap<String, Long> getPackageIds(DSLContext context, Vulnerability v) {
        var pkgIds = new HashMap<String, Long>();

        var uniqueBasePurls = v.getPurls().stream().map(purl -> purl.split("@")[0])
                .distinct().collect(Collectors.toList());

        for (String basePurl : uniqueBasePurls) {
            // Build the package name from the PURL
            var pkgName = basePurl.startsWith("pkg:maven") ? basePurl.substring(basePurl.indexOf("/") + 1)
                    : basePurl.substring(basePurl.lastIndexOf("/"));
            var coordinateSeparator = basePurl.startsWith("pkg:maven") ? Constants.mvnCoordinateSeparator : "";
            pkgName = pkgName.replace("/", coordinateSeparator);

            var pkgId = getPackageId(pkgName, context);
            if (pkgId > 0)
                pkgIds.put(basePurl, pkgId);
                cache.pkgIdToName.put(pkgId, pkgName);
        }

        return pkgIds;
    }

    /**
     * Get a list of packageVersion IDs from the PURLs in the vulnerability.
     * @param purls   - List of PURLS
     * @param context - DSL Context
     * @param pkgIds  - List of package version IDs
     * @param v - Vulnerability Object to inject PURLs of
     */
    public List<Long> getPackageVersionIds(List<String> purls,
                                           DSLContext context,
                                           HashMap<String, Long> pkgIds,
                                           Vulnerability v) {
        var pkgVersionIds = new ArrayList<Long>();
        var verifiedPurls = new ArrayList<String>();
        for (String purl : purls) {
            var purlObj = PURLPackage.getObjectFromPurl(purl);
            var pkgId = pkgIds.get(getBasePurl.apply(purl));
            var pkgVersionId = getPackageVersionId(purlObj, context, pkgId);
            if (pkgVersionId > 0L) {
                verifiedPurls.add(purl);
                pkgVersionIds.add(pkgVersionId);
                // Insert information in cache
                cache.pkgVsnToName.put(purlObj.getVersion(), cache.pkgIdToName.get(pkgId));
                cache.pkgNameToForge.put(cache.pkgIdToName.get(pkgId), purlObj.getType());
                cache.pkgVsnIdToVsn.put(pkgVersionId, purlObj.getVersion());
            }
        }
        if (v != null)  v.setPurls(verifiedPurls);
        return pkgVersionIds;
    }

    /**
     * Given a file and a package version id, looks for each hunk in the file.
     * The fasten_uri of each callable that is found at the linenumber indicated in the hunk
     * is then stored and returned.
     *
     * @param filename     - filename that was changed
     * @param lineNumbers  - lines to look for callables in the file
     * @param pkgVersionId - Long - ID of the package version
     * @return List of fastenURIs there fall under those lines
     */
    public HashSet<String> getFastenUrisForPatch(String filename,
                                                 List<Integer> lineNumbers,
                                                 Long pkgVersionId,
                                                 DSLContext context) {
        var fastenURIs = new HashSet<String>();

        // Get the fileID
        var fileId = getFileId(pkgVersionId, filename, context);
        if (fileId < 0) return fastenURIs;

        // There could be more moduleIds for the same file
        var moduleIds = getModuleIds(fileId, context);
        logger.info("Found " + moduleIds.size() + " module(s) corresponding to file with id " + fileId);

        for (Long moduleId : moduleIds) {
            for (Integer lineNumber : lineNumbers) {
                var fastenUrisInModule = getFastenUrisInModuleLines(moduleId, lineNumber, context);
                if (fastenUrisInModule.size() > 0) {
                    fastenURIs.addAll(fastenUrisInModule);
                }
            }
        }
        return fastenURIs;
    }

    /**
     * Retrieves fasten_uris in the module that include line_number.
     *
     * @param moduleId   - Long ID of the module
     * @param lineNumber - Indicates the line of the file where the change took place
     * @param context    - DSLContext
     * @return - List of fasten_uris
     */
    public List<String> getFastenUrisInModuleLines(Long moduleId, Integer lineNumber, DSLContext context) {
        var fasten_uris = context.select(Callables.CALLABLES.FASTEN_URI)
                .from(Callables.CALLABLES)
                .where(Callables.CALLABLES.MODULE_ID.equal(moduleId))
                .and(Callables.CALLABLES.LINE_START.le(lineNumber))
                .and(Callables.CALLABLES.LINE_END.ge(lineNumber))
                .fetch();

        return fasten_uris.stream().map(Record1::component1).collect(Collectors.toList());
    }

    /**
     * Retrieves the package_version_id given the purl of the package version.
     *
     * @param purlObj - purl object go bank the information
     * @return negative if it cannot be found
     */
    public Long getPackageVersionId(PURLPackage purlObj, DSLContext context, Long pkgId) {
        logger.info("Looking for package_version_id of " + purlObj.getName());
        assert pkgId > 0L;

        var pkgVersionRecord = context.select(PackageVersions.PACKAGE_VERSIONS.ID)
                .from(PackageVersions.PACKAGE_VERSIONS)
                .where(PackageVersions.PACKAGE_VERSIONS.PACKAGE_ID.equal(pkgId))
                .and(PackageVersions.PACKAGE_VERSIONS.VERSION.equal(purlObj.getVersion()))
                .fetchOne();
        return pkgVersionRecord != null ? pkgVersionRecord.component1() : -1L;
    }

    /**
     * Retrieve the fileId of the file that was patched.
     *
     * @param packageVersionId - Long pkg version ID
     * @param filepath         - path to the file
     * @return -1 if the file cannot be found
     */
    public Long getFileId(Long packageVersionId, String filepath, DSLContext context) {
        var fileRecords = context.select(Files.FILES.ID, Files.FILES.PATH)
                .from(Files.FILES)
                .where(Files.FILES.PACKAGE_VERSION_ID.equal(packageVersionId))
                .fetch();
        var file = fileRecords.stream()
                .filter(fr -> (!fr.component2().equals("") && filepath.contains(fr.component2())))
                .map(Record2::component1).collect(Collectors.toList());
        return file.size() > 0 ? file.get(0) : -1L;
    }

    /**
     * Gets the moduleId that corresponds to the file.
     *
     * @param fileId - Long fileId
     * @return list of module Ids
     */
    public List<Long> getModuleIds(Long fileId, DSLContext context) {
        var moduleRecords = context.select(ModuleContents.MODULE_CONTENTS.MODULE_ID)
                .from(ModuleContents.MODULE_CONTENTS)
                .where(ModuleContents.MODULE_CONTENTS.FILE_ID.equal(fileId))
                .fetch();
        return moduleRecords.stream().map(Record1::component1).collect(Collectors.toList());
    }

    /**
     * Returns package ID given PURL and CONTEXT (forge).
     *
     * @param pkgName - Package name
     * @param context - DSLContext
     * @return -1L if not existing
     */
    public Long getPackageId(String pkgName, DSLContext context) {
        var pkgRecord = context.select(Packages.PACKAGES.ID)
                .from(Packages.PACKAGES)
                .where(Packages.PACKAGES.PACKAGE_NAME.equal(pkgName))
                .fetchOne();
        return pkgRecord != null ? pkgRecord.component1() : -1L;
    }

    /**
     * Gets ids of callables with the fasten_uri, whose module belongs to a vulnerable package.
     *
     * @param fastenUri     - String
     * @param pkgVersionIds - List of Long vulnerable package versions
     * @param context       - DSL context
     * @return - List of ids of the callables
     */
    public HashSet<Long> getCallableIdsForFastenUri(String fastenUri, HashSet<Long> pkgVersionIds,
                                                 DSLContext context) {
        var callInfo = context.select(Callables.CALLABLES.ID, Modules.MODULES.PACKAGE_VERSION_ID)
                .from(Callables.CALLABLES)
                .join(Modules.MODULES).on(Modules.MODULES.ID.eq(Callables.CALLABLES.MODULE_ID))
                .where(Callables.CALLABLES.FASTEN_URI.equal(fastenUri))
                .and(Modules.MODULES.PACKAGE_VERSION_ID.in(pkgVersionIds))
                .fetch();

        var callIds = new HashSet<>(callInfo.map(Record2::value1));
//        callIds.addAll(callIdsSubProj);
        callInfo.forEach(r -> cache.callIdToPkgVsn.put(r.value1(), cache.pkgVsnIdToVsn.get(r.value2())));
        return callIds;
    }

    /**
     * Implements drill-down technique to find subprojects carrying the same callables.
     * @param pkgVersionIds - map of package versions
     * @param callIds - callable IDs of the main project
     * @param fastenUri - fasten_uri to drill
     * @param context - DSL context
     * @return - List of callable IDs that we were able to drill
     */
    public List<Long> getDrilledDownCallables(HashSet<Long> pkgVersionIds,
                                              Set<Long> callIds,
                                              String fastenUri,
                                              DSLContext context) {
        var callIdsSubProj = new ArrayList<Long>();
        var pkgVersions = pkgVersionIds.stream().map(id -> cache.pkgVsnIdToVsn.get(id)).collect(Collectors.toList());
        callIds.forEach(callId -> {
            var callInfoSubProjects = context.select(Callables.CALLABLES.ID, Modules.MODULES.PACKAGE_VERSION_ID)
                    .from(Callables.CALLABLES)
                    .join(Modules.MODULES).on(Modules.MODULES.ID.eq(Callables.CALLABLES.MODULE_ID))
                    .join(PackageVersions.PACKAGE_VERSIONS).on(PackageVersions.PACKAGE_VERSIONS.ID.eq(Modules.MODULES.PACKAGE_VERSION_ID))
                    .where(Callables.CALLABLES.FASTEN_URI.equal(fastenUri))
                    .and(PackageVersions.PACKAGE_VERSIONS.VERSION.in(pkgVersions))
                    .fetch();
            callInfoSubProjects.forEach(r -> {
                callIdsSubProj.add(r.value1());                                             // append to ids of sub_projects
                pkgVersionIds.add(r.value2());                                              // include into vulnerable_package_version_ids
                cache.callIdToPkgVsn.put(r.value1(), cache.pkgVsnIdToVsn.get(r.value2()));  // update cache with sub_project_info as well
            });
        });

        if (callIdsSubProj.size() > 0)  logger.info("Found " + (callIdsSubProj.size() - 1) + " extra callable(s) using drill-down");
        return callIdsSubProj;
    }

    /**
     * Builds a full fasten uri using information in the Cache
     * @param partialFastenUri - partial fasten_uri of the callable
     * @param callId - callable ID - Long
     * @return String - full_fasten_uri
     */
    public String getFullFastenUri(String partialFastenUri, Long callId) {
        var pkgVersion = cache.callIdToPkgVsn.get(callId);
        var pkgName = cache.pkgVsnToName.get(pkgVersion);
        var pkgForge = cache.pkgNameToForge.get(pkgName);
        return generateFullFastenUri(pkgForge, pkgName, pkgVersion, partialFastenUri);
    }

    //////////////////////////
    //    DATABASE INJECT   //
    //////////////////////////

    /**
     * Injects information at package level.
     *
     * @param v            - Vulnerability Object
     * @param pkgVersionId - ID of the package version
     * @param context      - DSLContext to use to inject the data
     */
    public void injectPackageVersionVulnerability(Vulnerability v, Long pkgVersionId, DSLContext context) {
        logger.info("Injecting vulnerability " + v.getId() + " into PACKAGE VERSION with ID: " + pkgVersionId);
        // Step 1: Get metadata JSONObject of the pkgVersionId
        var metadataRecord = context.select(PackageVersions.PACKAGE_VERSIONS.METADATA)
                .from(PackageVersions.PACKAGE_VERSIONS)
                .where(PackageVersions.PACKAGE_VERSIONS.ID.equal(pkgVersionId))
                .fetchOne()
                .component1();

        var metadata = new JSONObject(metadataRecord.data());

        // Step 2: Check if vulnerabilities exist, else create a map
        if (!metadata.has("vulnerabilities"))
            metadata.put("vulnerabilities", new JSONObject());

        // Step 3: Get the JSON of the vulnerability and put it in the metadata
        try {
            var vulnJson = objectMapper.writeValueAsString(v);
            ((JSONObject) metadata.get("vulnerabilities")).put(v.getId(), new JSONObject(vulnJson));
        } catch (JsonProcessingException e) {
            e.printStackTrace();
        }

        // Step 4: Update the value of the metadata in the DB
        context.update(PackageVersions.PACKAGE_VERSIONS)
                .set(PackageVersions.PACKAGE_VERSIONS.METADATA, JSONB.valueOf(metadata.toString()))
                .where(PackageVersions.PACKAGE_VERSIONS.ID.equal(pkgVersionId))
                .execute();
    }

    /**
     * Injects information at callable level.
     *
     * @param v          - Vulnerability Object
     * @param callableId - ID of the callable
     * @param context    - DSLContext to use to inject the data
     * @return
     */
    public int injectCallableVulnerability(Vulnerability v, Long callableId, DSLContext context) {
        logger.info("Injecting vulnerability " + v.getId() + " into CALLABLE with ID: " + callableId);
        // Step 1: Get metadata JSONObject of the callableId
        var metadataRecord = context.select(Callables.CALLABLES.METADATA)
                .from(Callables.CALLABLES)
                .where(Callables.CALLABLES.ID.equal(callableId))
                .fetchOne()
                .component1();

        var metadata = new JSONObject(metadataRecord.data());

        // Step 2: Check if vulnerabilities exist, else create a map
        if (!metadata.has("vulnerabilities"))
            metadata.put("vulnerabilities", new JSONObject());

        // Step 3: Get the JSON of the vulnerability and put it in the metadata
        try {
            var vulnJson = objectMapper.writeValueAsString(v);
            ((JSONObject) metadata.get("vulnerabilities")).put(v.getId(), new JSONObject(vulnJson));
        } catch (JsonProcessingException e) {
            e.printStackTrace();
        }

        // Step 4: Update the value of the metadata in the DB
        return context.update(Callables.CALLABLES)
                .set(Callables.CALLABLES.METADATA, JSONB.valueOf(metadata.toString()))
                .where(Callables.CALLABLES.ID.equal(callableId))
                .execute();
    }

    //////////////////////////
    //    DATABASE PURGE    //
    //////////////////////////

    /**
     *  Purges all vulnerability information from the DB.
     * @param contexts - DSL contexts to be purged
     */
    public void purgeFromDB(Map<String, DSLContext> contexts) {
        // Purge each of the DBs
        for (String ecosystem : contexts.keySet()) {
            var context = contexts.get(ecosystem);
            logger.info("Clearing DB for " + ecosystem);
            // Package Versions
            var vulnPkgIds = context.select(PackageVersions.PACKAGE_VERSIONS.ID)
                    .from(PackageVersions.PACKAGE_VERSIONS)
                    .where(DSL.field("metadata -> 'vulnerabilities'").isNotNull())
                    .fetch();

            var vulnPkgUpdates = new ArrayList<UpdateConditionStep<PackageVersionsRecord>>();

            vulnPkgIds.forEach(record -> {
                vulnPkgUpdates.add(context.update(PackageVersions.PACKAGE_VERSIONS)
                        .set(DSL.field("metadata"), (Object) DSL.field("metadata - 'vulnerabilities'"))
                        .where(PackageVersions.PACKAGE_VERSIONS.ID.eq(record.component1())));
            });

            context.batch(vulnPkgUpdates).execute();
            logger.info("Cleaned " + vulnPkgUpdates.size() + " vulnerabilities from Package Versions Table");

            // Callables
            var vulnCallIds = context.select(Callables.CALLABLES.ID)
                    .from(Callables.CALLABLES)
                    .where(DSL.field("metadata -> 'vulnerabilities'").isNotNull())
                    .fetch();

            var vulnCallUpdates = new ArrayList<UpdateConditionStep<CallablesRecord>>();

            vulnCallIds.forEach(record -> {
                vulnCallUpdates.add(context.update(Callables.CALLABLES)
                        .set(DSL.field("metadata"), (Object) DSL.field("metadata - 'vulnerabilities'"))
                        .where(Callables.CALLABLES.ID.eq(record.component1())));
            });

            context.batch(vulnCallUpdates).execute();
            logger.info("Cleaned " + vulnCallUpdates.size() + " vulnerabilities from Callables Table");
        }
    }

    /**
     * Helper function to find if callable information for the given package version are not in KB.
     * @param pkgVersionIds - Long
     * @param context - DSLContext
     * @return True if no module is found
     */
    public boolean areCallablesMissing(Long pkgVersionIds, DSLContext context) {
        return context.selectCount().from(Modules.MODULES)
                .where(Modules.MODULES.PACKAGE_VERSION_ID.eq(pkgVersionIds)).execute() <= 0;
    }

    /**
     * Sends HTTP GET request to API to lazy ingest things.
     * @param pkgCoord - String
     */
    public void sendIngestRequest(String pkgCoord) {
        try {
            var apiUrl = System.getenv(fastenApiUrlEnvVariable);
            if(Objects.isNull(apiUrl)) {
                apiUrl = fastenApiUrlDefault;
            }
            var url = new URL(apiUrl + pkgCoord);
            var con = (HttpURLConnection) url.openConnection();
            con.setRequestMethod("GET");
            int status = con.getResponseCode();
            if (status == 201) {
                logger.info("Successfully sent request to lazily ingest " + pkgCoord);
            }
        } catch (IOException e) {
            logger.error("Could not send request to lazy ingest");
        }
    }
}
