/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.analyzer.vulnerabilityconsumer.db;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import eu.fasten.analyzer.vulnerabilityconsumer.utils.Cache;
import eu.fasten.analyzer.vulnerabilityconsumer.utils.PURLPackage;
import eu.fasten.analyzer.vulnerabilityconsumer.utils.Vulnerability;
import eu.fasten.core.data.Constants;
import eu.fasten.core.data.metadatadb.codegen.tables.*;
import eu.fasten.core.data.metadatadb.codegen.tables.records.CallablesRecord;
import eu.fasten.core.data.metadatadb.codegen.tables.records.PackageVersionsRecord;
import org.jooq.*;
import org.jooq.impl.DSL;
import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;
import java.util.function.UnaryOperator;
import java.util.stream.Collectors;

import static eu.fasten.core.utils.FastenUriUtils.generateFullFastenUri;


public class MetadataUtility {

    private ObjectMapper objectMapper = new ObjectMapper();
    private Cache cache = new Cache();
    private UnaryOperator<String> getBasePurl = s -> s.split("@")[0];
    private final Logger logger = LoggerFactory.getLogger(MetadataUtility.class.getName());

    public MetadataUtility() {
    }

    /**
     * Looks for Unique Base PURLs and find the corresponding package ID.
     *
     * @param context - DSL Context
     * @param v       - Vulnerability Object
     * @return Map (basePURL --> pkgId)
     */
    public HashMap<String, Long> getPackageIds(DSLContext context, Vulnerability v) {
        var pkgIds = new HashMap<String, Long>();

        var uniqueBasePurls = v.getPurls().stream().map(purl -> purl.split("@")[0])
                .distinct().collect(Collectors.toList());

        for (String basePurl : uniqueBasePurls) {
            // Build the package name from the PURL
            var pkgName = basePurl.startsWith("pkg:maven") ? basePurl.substring(basePurl.indexOf("/") + 1)
                    : basePurl.substring(basePurl.lastIndexOf("/"));
            var coordinateSeparator = basePurl.startsWith("pkg:maven") ? Constants.mvnCoordinateSeparator : "";
            pkgName = pkgName.replace("/", coordinateSeparator);

            var pkgId = getPackageId(pkgName, context);
            if (pkgId > 0)
                pkgIds.put(basePurl, pkgId);
                cache.pkgIdToName.put(pkgId, pkgName);
        }

        return pkgIds;
    }

    /**
     * Get a list of packageVersion IDs from the PURLs in the vulnerability.
     *  @param purls   - List of PURLS
     * @param context - DSL Context
     * @param pkgIds  - List of package version IDs
     */
    public List<Long> getPackageVersionIds(List<String> purls, DSLContext context,
                                           HashMap<String, Long> pkgIds) {
        var pkgVersionIds = new ArrayList<Long>();
        for (String purl : purls) {
            var purlObj = PURLPackage.getObjectFromPurl(purl);
            var pkgId = pkgIds.get(getBasePurl.apply(purl));
            var pkgVersionId = getPackageVersionId(purlObj, context, pkgId);
            if (pkgVersionId > 0L) {
                pkgVersionIds.add(pkgVersionId);
                // Insert information in cache
                cache.pkgVsnToName.put(purlObj.getVersion(), cache.pkgIdToName.get(pkgId));
                cache.pkgVsnIdToVsn.put(pkgVersionId, purlObj.getVersion());
            }
        }

        return pkgVersionIds;
    }

    /**
     * Given a file and a package version id, looks for each hunk in the file.
     * The fasten_uri of each callable that is found at the linenumber indicated in the hunk
     * is then stored and returned.
     *
     * @param patch        - that contains hunks with the changes to the file
     * @param pkgVersionId - Long - ID of the package version
     * @return List of fastenURIs to
     */
    public HashSet<String> getFastenUrisForPatch(Vulnerability.Patch patch, Long pkgVersionId,
                                                 DSLContext context) {
        var fastenURIs = new HashSet<String>();

        // Get the fileID
        var fileId = getFileId(pkgVersionId, patch.getFileName(), context);
        if (fileId < 0) return fastenURIs;

        // There could be more moduleIds for the same file
        var moduleIds = getModuleIds(fileId, context);
        logger.info("Found " + moduleIds.size() + " module(s) corresponding to file with id " + fileId);

        for (Long moduleId : moduleIds) {
            for (Integer lineNumber : patch.getLineNumbers()) {
                var fastenUrisInModule = getFastenUrisInModuleLines(moduleId, lineNumber, context);
                if (fastenUrisInModule.size() > 0) fastenURIs.addAll(fastenUrisInModule);
            }
        }
        return fastenURIs;
    }

    /**
     * Retrieves fasten_uris in the module that include line_number.
     *
     * @param moduleId   - Long ID of the module
     * @param lineNumber - Indicates the line of the file where the change took place
     * @param context    - DSLContext
     * @return - List of fasten_uris
     */
    public List<String> getFastenUrisInModuleLines(Long moduleId, Integer lineNumber, DSLContext context) {
        var fasten_uris = context.select(Callables.CALLABLES.FASTEN_URI)
                .from(Callables.CALLABLES)
                .where(Callables.CALLABLES.MODULE_ID.equal(moduleId))
                .and(Callables.CALLABLES.LINE_START.le(lineNumber))
                .and(Callables.CALLABLES.LINE_END.ge(lineNumber))
                .fetch();

        return fasten_uris.stream().map(Record1::component1).collect(Collectors.toList());
    }

    /**
     * Retrieves the package_version_id given the purl of the package version.
     *
     * @param purlObj - purl object go bank the information
     * @return negative if it cannot be found
     */
    public Long getPackageVersionId(PURLPackage purlObj, DSLContext context, Long pkgId) {
        logger.info("Looking for package_version_id of " + purlObj.getName());
        assert pkgId > 0L;

        var pkgVersionRecord = context.select(PackageVersions.PACKAGE_VERSIONS.ID)
                .from(PackageVersions.PACKAGE_VERSIONS)
                .where(PackageVersions.PACKAGE_VERSIONS.PACKAGE_ID.equal(pkgId))
                .and(PackageVersions.PACKAGE_VERSIONS.VERSION.equal(purlObj.getVersion()))
                .fetchOne();
        return pkgVersionRecord != null ? pkgVersionRecord.component1() : -1L;
    }

    /**
     * Retrieve the fileId of the file that was patched.
     *
     * @param packageVersionId - Long pkg version ID
     * @param filepath         - path to the file
     * @return -1 if the file cannot be found
     */
    public Long getFileId(Long packageVersionId, String filepath, DSLContext context) {
        var fileRecords = context.select(Files.FILES.ID, Files.FILES.PATH)
                .from(Files.FILES)
                .where(Files.FILES.PACKAGE_VERSION_ID.equal(packageVersionId))
                .fetch();
        var file = fileRecords.stream()
                .filter(fr -> (!fr.component2().equals("") && filepath.contains(fr.component2())))
                .map(Record2::component1).collect(Collectors.toList());
        return file.size() > 0 ? file.get(0) : -1L;
    }

    /**
     * Gets the moduleId that corresponds to the file.
     *
     * @param fileId - Long fileId
     * @return list of module Ids
     */
    public List<Long> getModuleIds(Long fileId, DSLContext context) {
        var moduleRecords = context.select(ModuleContents.MODULE_CONTENTS.MODULE_ID)
                .from(ModuleContents.MODULE_CONTENTS)
                .where(ModuleContents.MODULE_CONTENTS.FILE_ID.equal(fileId))
                .fetch();
        return moduleRecords.stream().map(Record1::component1).collect(Collectors.toList());
    }

    /**
     * Returns package ID given PURL and CONTEXT (forge).
     *
     * @param pkgName - Package name
     * @param context - DSLContext
     * @return -1L if not existing
     */
    public Long getPackageId(String pkgName, DSLContext context) {
        var pkgRecord = context.select(Packages.PACKAGES.ID)
                .from(Packages.PACKAGES)
                .where(Packages.PACKAGES.PACKAGE_NAME.equal(pkgName))
                .fetchOne();
        return pkgRecord != null ? pkgRecord.component1() : -1L;
    }

    /**
     * Gets ids of callables with the fasten_uri, whose module belongs to a vulnerable package.
     *
     * @param fastenUri     - String
     * @param pkgVersionIds - List of Long vulnerable package versions
     * @param context       - DSL context
     * @return - List of ids of the callables
     */
    public List<Long> getCallableIdsForFastenUri(String fastenUri, List<Long> pkgVersionIds,
                                                 DSLContext context) {
        // Gets callables IDS with given fasten_uri
        var callInfo = context.select(Callables.CALLABLES.ID, Modules.MODULES.NAMESPACE,
                Modules.MODULES.PACKAGE_VERSION_ID)
                .from(Callables.CALLABLES)
                .join(Modules.MODULES).on(Modules.MODULES.ID.eq(Callables.CALLABLES.MODULE_ID))
                .where(Callables.CALLABLES.FASTEN_URI.equal(fastenUri))
                .and(Modules.MODULES.PACKAGE_VERSION_ID.in(pkgVersionIds))
                .fetch();

        // Inject info into cache
        callInfo.forEach(r -> cache.mdlNamespaceToPkgVsn.put(r.value2(), cache.pkgVsnIdToVsn.get(r.value3())));
        callInfo.forEach(r -> cache.callIdToNamespace.put(r.value1(), r.value2()));
        return new ArrayList<>(callInfo.map(Record3::value1));
    }

    /**
     * Builds a full fasten uri using information in the Cache
     * @param partialFastenUri - partial fasten_uri of the callable
     * @param callId - callable ID - Long
     * @return String - full_fasten_uri
     */
    public String getFullFastenUri(String partialFastenUri, Long callId) {
        var moduleNamespace = cache.callIdToNamespace.get(callId);
        var pkgVersion = cache.mdlNamespaceToPkgVsn.get(moduleNamespace);
        var pkgName = cache.pkgVsnToName.get(pkgVersion);
        return generateFullFastenUri(pkgName, pkgVersion, moduleNamespace, partialFastenUri);
    }

    //////////////////////////
    //    DATABASE INJECT   //
    //////////////////////////

    /**
     * Injects information at package level.
     *
     * @param v            - Vulnerability Object
     * @param pkgVersionId - ID of the package version
     * @param context      - DSLContext to use to inject the data
     */
    public void injectPackageVersionVulnerability(Vulnerability v, Long pkgVersionId, DSLContext context) {
        logger.info("Injecting vulnerability " + v.getId() + " into PACKAGE VERSION with ID: " + pkgVersionId);
        // Step 1: Get metadata JSONObject of the pkgVersionId
        var metadataRecord = context.select(PackageVersions.PACKAGE_VERSIONS.METADATA)
                .from(PackageVersions.PACKAGE_VERSIONS)
                .where(PackageVersions.PACKAGE_VERSIONS.ID.equal(pkgVersionId))
                .fetchOne()
                .component1();

        var metadata = new JSONObject(metadataRecord.data());

        // Step 2: Check if vulnerabilities exist, else create a map
        if (!metadata.has("vulnerabilities"))
            metadata.put("vulnerabilities", new JSONObject());

        // Step 3: Get the JSON of the vulnerability and put it in the metadata
        try {
            var vulnJson = objectMapper.writeValueAsString(v);
            ((JSONObject) metadata.get("vulnerabilities")).put(v.getId(), new JSONObject(vulnJson));
        } catch (JsonProcessingException e) {
            e.printStackTrace();
        }

        // Step 4: Update the value of the metadata in the DB
        context.update(PackageVersions.PACKAGE_VERSIONS)
                .set(PackageVersions.PACKAGE_VERSIONS.METADATA, JSONB.valueOf(metadata.toString()))
                .where(PackageVersions.PACKAGE_VERSIONS.ID.equal(pkgVersionId))
                .execute();
    }

    /**
     * Injects information at callable level.
     *
     * @param v          - Vulnerability Object
     * @param callableId - ID of the callable
     * @param context    - DSLContext to use to inject the data
     * @return
     */
    public int injectCallableVulnerability(Vulnerability v, Long callableId, DSLContext context) {
        logger.info("Injecting vulnerability " + v.getId() + " into CALLABLE with ID: " + callableId);
        // Step 1: Get metadata JSONObject of the callableId
        var metadataRecord = context.select(Callables.CALLABLES.METADATA)
                .from(Callables.CALLABLES)
                .where(Callables.CALLABLES.ID.equal(callableId))
                .fetchOne()
                .component1();

        var metadata = new JSONObject(metadataRecord.data());

        // Step 2: Check if vulnerabilities exist, else create a map
        if (!metadata.has("vulnerabilities"))
            metadata.put("vulnerabilities", new JSONObject());

        // Step 3: Get the JSON of the vulnerability and put it in the metadata
        try {
            var vulnJson = objectMapper.writeValueAsString(v);
            ((JSONObject) metadata.get("vulnerabilities")).put(v.getId(), new JSONObject(vulnJson));
        } catch (JsonProcessingException e) {
            e.printStackTrace();
        }

        // Step 4: Update the value of the metadata in the DB
        return context.update(Callables.CALLABLES)
                .set(Callables.CALLABLES.METADATA, JSONB.valueOf(metadata.toString()))
                .where(Callables.CALLABLES.ID.equal(callableId))
                .execute();
    }

    //////////////////////////
    //    DATABASE PURGE    //
    //////////////////////////

    /**
     *  Purges all vulnerability information from the DB.
     * @param contexts - DSL contexts to be purged
     */
    public void purgeFromDB(Map<String, DSLContext> contexts) {
        // Purge each of the DBs
        for (String ecosystem : contexts.keySet()) {
            var context = contexts.get(ecosystem);
            logger.info("Clearing DB for " + ecosystem);
            // Package Versions
            var vulnPkgIds = context.select(PackageVersions.PACKAGE_VERSIONS.ID)
                    .from(PackageVersions.PACKAGE_VERSIONS)
                    .where(DSL.field("metadata -> 'vulnerabilities'").isNotNull())
                    .fetch();

            var vulnPkgUpdates = new ArrayList<UpdateConditionStep<PackageVersionsRecord>>();

            vulnPkgIds.forEach(record -> {
                vulnPkgUpdates.add(context.update(PackageVersions.PACKAGE_VERSIONS)
                        .set(DSL.field("metadata"), (Object) DSL.field("metadata - 'vulnerabilities'"))
                        .where(PackageVersions.PACKAGE_VERSIONS.ID.eq(record.component1())));
            });

            context.batch(vulnPkgUpdates).execute();
            logger.info("Cleaned " + vulnPkgUpdates.size() + " vulnerabilities from Package Versions Table");

            // Callables
            var vulnCallIds = context.select(Callables.CALLABLES.ID)
                    .from(Callables.CALLABLES)
                    .where(DSL.field("metadata -> 'vulnerabilities'").isNotNull())
                    .fetch();

            var vulnCallUpdates = new ArrayList<UpdateConditionStep<CallablesRecord>>();

            vulnCallIds.forEach(record -> {
                vulnCallUpdates.add(context.update(Callables.CALLABLES)
                        .set(DSL.field("metadata"), (Object) DSL.field("metadata - 'vulnerabilities'"))
                        .where(Callables.CALLABLES.ID.eq(record.component1())));
            });

            context.batch(vulnCallUpdates).execute();
            logger.info("Cleaned " + vulnCallUpdates.size() + " vulnerabilities from Callables Table");
        }
    }
}
